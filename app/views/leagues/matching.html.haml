- @title = @league.name
.matching
  .left
    .internal
      #status
      #match_players
        .internal
          %ul.list
      #exit{:style => 'display: none'}
        = form_tag "#", :id => "leave_current_match_form" do
          = submit_tag t('.leave_current_match'), :class => "sad"
    .internal.chatting
      = render :partial => 'chat'
    -#.internal
      -#= render :partial => 'active_players'
  .right
    #question
:javascript
  var leagueId = #{@league.id};
  var questionsPerMatch = #{MatchingSettings.questions_per_match};
  var questionsPerCacheBlock = #{MatchingSettings.questions_per_cache_block};
  var questionsRefillThreshold = #{MatchingSettings.questions_refill_threshold};
  var statusRecheckInterval = #{MatchingSettings.status_recheck_interval} * 1000;
  var requestingMatchInfo = false;
  var matchId;
  var retried = 0;
  var questions = [];
  var counterHandle;
  var remainedTime;
  var loadingMoreQuestions = false;
  var questionsLoadedCallback;
  var currentStatus;
  var backloggedMessages = [];
  var playerViews = {};
  var matchInfo = {};

  var MAX_RETRIES = 20;

  var statusHTML = #{['waiting', 'formed', 'started', 'you_finished'].inject({}){|hash, key| hash[key] = t "matches.#{key}"; hash}.to_json};
  var playerHTML = #{render(:partial => "users/player", :locals => { :avatar_size => '{avatar_size}', :avatar_url => '{avatar_url}', :display_name => '{display_name}'}).to_json};

  $(function(){
    requestMatch();
  })

  var requestMatch = Retrier.newAjaxFunc(function(force){
    var data = {};
    if (force) data.force = true;
    return {
      type: 'post',
      url: "/#{I18n.locale}/leagues/" + leagueId + "/request_match",
      data: data,
      dataType: 'json',
      success: function(data){
        if (data.match_id){
          matchId = data.match_id;
          subscribeMatch(data.match_id);
        } else {
          setTimeout(requestMatch, 1000);
        }
      }
    }
  });

  function subscribeMatch(){
    var client = new Faye.Client("#{SiteSettings.pubsub.server}/#{SiteSettings.pubsub.mount_point}");
    var channel = '/matches/' + matchId;
    initialRequestComplete = false;
    client.subscribe(channel, function(message){
      if (initialRequestComplete){
        processMessage(message);
      } else {
        backloggedMessages.push(message);
      }
    });

    registerMatch();
  }

  function processMessage(message){
    switch(message.type){
      case "join":
      case "player_update":
        showPlayer(message.user);
        break;
      case "status_changed":
        setMatchInfo(message.info);
        break;
    }
  }

  function requestCurrentQuestion(callback){
    if (matchInfo.current_question_position >= questions.length){
      loadMoreQuestions(function(){ requestCurrentQuestion(callback) });
    } else {
      callback(questions[matchInfo.current_question_position]);
      if (matchInfo.current_question_position >= questions.length - questionsRefillThreshold) {
        loadMoreQuestions(null);
      }
    }
  }

  var registerMatch = Retrier.newAjaxFunc(function(){
    return {
      type: 'post',
      url: "/#{I18n.locale}/matches/" + matchId + "/register",
      dataType: 'json',
      success: function(info){
        if (info) {
          setMatchInfo(info);
          initialRequestComplete = true;
          for (var i=0; i < backloggedMessages.length; i++) processMessage(backloggedMessages[i]);
        } else {
          requestMatch(true);
        }
      }
    }
  });

  var loadMoreQuestions = Retrier.newAjaxFunc(function(callback){
    if (callback != null) questionsLoadedCallback = callback;
    return loadingMoreQuestions ? null : {
      type: 'post',
      url: ["/#{I18n.locale}/matches/", matchId, "/more_questions"].join(""),
      data: {
        loaded: questions.length
      },
      dataType: 'json',
      beforeSend: function(){
        loadingMoreQuestions = true;
      },
      success:function(data){
        questions = questions.concat(data);
        if (questionsLoadedCallback) {
          var c = questionsLoadedCallback;
          questionsLoadedCallback = null;
          c();
        }
      },
      complete: function(){
        loadingMoreQuestions = false;
      }
    }
  });

  function meFinished(){
    return matchInfo.current_question_position == questionsPerMatch
  }

  function setMatchInfo(info, forceRefresh){
    forceRefresh = forceRefresh || (info.status != matchInfo.status);
    $.extend(matchInfo, info);

    if (matchInfo.status){
      setMatchStatus(matchInfo.status, matchInfo);
      switch (matchInfo.status){
        case 'formed':
          showCounter(info.seconds_until_start);
          break;
        case 'started':
          showCounter(info.seconds_until_end);
          break;
        default:
          stopCounter();
      }
    }

    if (forceRefresh){
      if (matchInfo.status == 'started' && !meFinished()){
        //switch from no question -> current questions
        matchInfo.current_question_position = matchInfo.current_question_position || 0
        requestCurrentQuestion(setQuestion);
      } else if ((matchInfo.status == 'started' && meFinished()) || matchInfo.status == 'finished') clearQuestion();
    }

    $.each(info.players || [], function(index, player){
      showPlayer(player);
    });
  }

  function stopCounter(){
    if (counterHandle) {clearTimeout(counterHandle);}
  }

  function showCounter(time){
    stopCounter();
    remainedTime = time;
    counterHandle = setTimeout(refreshCounter, 1000);
  }

  var expectStatus = Retrier.newAjaxFunc(function(status){
    return {
      url: "/#{I18n.locale}/matches/" + matchId + "/brief",
      success: function(info){
        if (info.status != status) {
          setTimeout(function(){expectStatus(status)}, 1000);
        } else {
          setMatchInfo(info);
        }
      }
    }
  });

  function refreshCounter(){
    if (remainedTime== 0){
      switch (matchInfo.status){
        case 'formed':
          setMatchInfo({ status: 'started', seconds_until_end: matchInfo.duration });
          break;
        case 'started':
          expectStatus('finished');
          break;
      }
    } else {
      remainedTime--;
      var params;
      if (matchInfo.status == 'formed'){
        params = { seconds_until_start: remainedTime}
      } else {
        params = { seconds_until_end: remainedTime}
      }
      setMatchStatus(matchInfo.status, params);
      counterHandle = setTimeout(refreshCounter, 1000);
    }
  }

  var sendAnswer = Retrier.newAjaxFunc(function(answer){
    return {
      type: 'post',
      url: ["/#{I18n.locale}/matches/", matchId, "/submit_answer"].join(""),
      dataType: 'json',
      data: answer
    }
  });

  function submitAnswer(currentAnswer){
    disableQuestionButtonsAndInputs();
    var answer = {
      position: matchInfo.current_question_position
    }
    if (currentAnswer != null) answer.answer = currentAnswer;
    sendAnswer(answer);
    matchInfo.current_question_position++;
    if (matchInfo.current_question_position < questionsPerMatch){
      requestCurrentQuestion(setQuestion);
    } else {
      setMatchInfo({status: "started", seconds_until_end: remainedTime}, true)
    }
  }

  function highlightPattern(input){
    var hint = $(input).data('hint');
    var val = $(input).val();
    function span(ch, clazz){
      return ["<span class='", clazz, "'>", ch, "</span>"].join("");
    }

    var parts = [];
    for (var i = 0; i < Math.max(hint.length, val.length); i++){
      if (i >= val.length){
        parts.push(span(hint.charAt(i), "gray"));
      } else if (i >= hint.length){
        parts.push(span(val.charAt(i), "purple"));
      } else if (hint.charAt(i) == '*') {
        parts.push(span('*', "green"));
      } else if (hint.charAt(i) == val.charAt(i)){
        parts.push(span(hint.charAt(i) == ' ' ? '_' : hint.charAt(i), "green"));
      } else {/*hint.charAt(i) != val.charAt(i)*/
        parts.push(span(hint.charAt(i) == ' ' ? '_' : hint.charAt(i), "red"));
      }
    }

    $(input).data('hinter').html(parts.join(""));
  }

  function formatString(template, variables){
    var formatted = template;
    for (var key in variables){
      formatted = formatted.replace(new RegExp('{'+key+'}', 'g'), variables[key]);
    }
    return formatted;
  }

  function setMatchStatus(status, info){
    matchInfo.status = status;
    if (status == 'finished') {
      window.location.replace(info['result_url']);
    } else {
      var templateName = (status == 'started' && meFinished()) ? 'you_finished' : status;
      $('#status').html(formatString(statusHTML[templateName], info));
      if (status == "waiting")
        $('#exit').hide();
      else {
        $('#exit').find('form').attr("action", "/matches/" + matchId + "/unsubscribe");
        $('#exit').find('form').submit(function(){return confirm(#{t(".leave_current_match_confirm").to_json});});
        $('#exit').show();
      }
    }
  }

  function newPlayerView(player){
    var view = $(formatString(playerHTML, $.extend({}, player, { avatar_size: 40 })));
    view.data('player', player);
    if ($('#match_players ul.list li').size() != 0) view.addClass("notfirst");
    $('#match_players ul.list').append(view);
    return view;
  }

  function getPlayerView(player){
    return (playerViews[player.id] || (playerViews[player.id] = newPlayerView(player)));
  }

  function showPlayer(player){
    var view = getPlayerView(player);
    var started = (matchInfo.status != 'formed' && matchInfo.status != 'waiting');
    var finished = started && player.current_question_position == questionsPerMatch;
    var title = view.data('player').display_name;
    if (started){
      if (finished){
        title += " (finished)"
      } else {
        title += " (" + (player.current_question_position + 1) + "/" + questionsPerMatch + ")";
      }
      var iw = 40;
      var fw = view.parent().width();
      view.find('img').css({marginLeft: (fw - iw) * player.current_question_position / questionsPerMatch + "px"})
    }

    view.find('img').attr('title', title);
  }

  function setQuestion(question){
    $('#question').html(question.content);
    setUpQuestionButtons(question.type);
    if (window.refreshMathFormulae) refreshMathFormulae('question');
  }

  function setUpQuestionButtons(questionType){
    $('#question form').submit(function(event){
      setTimeout(function(){
        submitAnswer(getAnswer());
      }, 0);
      return false;
    });

    $('#question input[type=text]:first').focus();
    $('#question #ignore').click(function(event){
      submitAnswer(null);
    });
  }

  function bindHighlight(input, hinter){
    $(input).data('hint', $(hinter).text());
    $(input).data('hinter', $(hinter));
    $(input).keyup(function(event){
      highlightPattern(this);
    });
  }

  function disableQuestionButtonsAndInputs(){
    $('#question').find('button, input').attr('disabled', 'disabled');
  }

  function clearQuestion(){
    $('#question').empty();
  }
